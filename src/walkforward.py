# walkforward.py
# This script contains the core logic for running a robust walk-forward backtest.
# It uses a TimeSeriesSplit to simulate a real-world scenario of
# training a model on historical data and testing it on new, unseen data.

import pandas as pd
import numpy as np
from backtesting import Backtest
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import TimeSeriesSplit

# Assuming create_target_variable is in a local file.
# This function is crucial for preparing the data with the target variable for the ML model.
from src.stock_features import create_target_variable


def train_model(X_train, y_train):
    """
    Trains a fresh RandomForestClassifier model on the provided training data.
    This function is called repeatedly for each fold of the walk-forward backtest.

    Args:
        X_train (pd.DataFrame): The feature data for training.
        y_train (pd.Series): The target variable for training.

    Returns:
        RandomForestClassifier: A fitted RandomForest model.
    """
    model = RandomForestClassifier(
        n_estimators=200,    # Number of trees in the forest.
        max_depth=6,         # The maximum depth of the tree.
        random_state=42,     # Ensures reproducibility of the results.
        n_jobs=-1            # Use all available CPU cores for faster training.
    )
    model.fit(X_train, y_train)
    return model


def walk_forward_backtest(
    data,
    target_ticker,
    window,
    threshold,
    backtest_start_date,
    trading_strategy,
    n_splits=3,
    cash=10000,
    commission=0.001,
    val_fraction=0.2
):
    """
    Runs a walk-forward backtest by splitting the data into folds, training a model
    on each fold's training data, and then backtesting on the subsequent test data.

    Args:
        data (pd.DataFrame): The full dataset including features and prices.
        target_ticker (str): The ticker symbol of the stock to trade.
        window (int): The look-ahead window for the target variable creation.
        threshold (float): The return threshold for the target variable.
        backtest_start_date (str): The date from which to start the actual backtesting.
        trading_strategy (class): The backtesting.py strategy class to use.
        n_splits (int): The number of splits (folds) for the walk-forward test.
        cash (float): The starting capital for each backtest.
        commission (float): The trading commission per trade.
        val_fraction (float): Not used in this implementation but often used for
                              validation sets in more complex walk-forward schemes.
    
    Returns:
        tuple: A tuple containing:
            - all_stats (list): A list of Backtest results (stats) for each fold.
            - full_equity (pd.Series): The concatenated equity curve from all folds.
            - metrics_summary (pd.DataFrame): A summary of key metrics across all folds.
    """
    # Create the target variable based on the specified window and threshold.
    df = create_target_variable(data.copy(), target_ticker, window=window, threshold=threshold)
    target_col = f"{target_ticker}_Target"
    target_return_col = f"{target_ticker}_target_return_{window}D_{threshold}"

    # Define the columns to drop before training the model.
    # These are the price and volume columns which should not be used as features.
    drop_cols = [
        target_col,
        target_return_col,
        f"Open_{target_ticker}",
        f"High_{target_ticker}",
        f"Low_{target_ticker}",
        f"Close_{target_ticker}"
    ]
    df.dropna(inplace=True)

    # Separate features (X) and the target variable (y).
    X = df.drop(columns=drop_cols)
    y = df[target_col]

    # Initialize TimeSeriesSplit, which creates chronological folds.
    tscv = TimeSeriesSplit(n_splits=n_splits)
    
    # Lists to store results from each fold.
    all_stats = []
    equity_curves = []

    # Iterate through each fold generated by TimeSeriesSplit.
    for fold, (train_idx, test_idx) in enumerate(tscv.split(X)):
        X_train, X_test = X.iloc[train_idx], X.iloc[test_idx]
        y_train = y.iloc[train_idx]
        
        # We only start the backtest after the defined `backtest_start_date`.
        # This allows for a warm-up period for the model.
        if X_test.index[0] < pd.to_datetime(backtest_start_date):
            print(f"Skipping fold {fold+1}: Test period starts before backtest_start_date.")
            continue

        print(f"\n=== Fold {fold+1}: Train {X_train.index[0]} → {X_train.index[-1]}, Test {X_test.index[0]} → {X_test.index[-1]} ===")

        # Train a new model on the data from this fold's training period.
        model = train_model(X_train, y_train)

        # Use the newly trained model to predict the test period.
        # This is a key step to avoid look-ahead bias.
        df.loc[X_test.index, "Prediction"] = model.predict(X_test)

        # Prepare the OHLCV (Open, High, Low, Close, Volume) data for the backtest.py library.
        # This OHLCV data is strictly for the current test fold.
        ohlc = df.loc[X_test.index, [
            f"Open_{target_ticker}",
            f"High_{target_ticker}",
            f"Low_{target_ticker}",
            f"Close_{target_ticker}",
            f"Volume_{target_ticker}",
            "Prediction" # Include the prediction to be used by the strategy
        ]].rename(columns={
            f"Open_{target_ticker}": "Open",
            f"High_{target_ticker}": "High",
            f"Low_{target_ticker}": "Low",
            f"Close_{target_ticker}": "Close",
            f"Volume_{target_ticker}": "Volume"
        })
        
        # Check if OHLC data is valid for backtest
        if ohlc.empty:
            print(f"Skipping fold {fold+1}: OHLC data is empty.")
            continue

        # Run backtest for this fold with the designated trading strategy.
        bt = Backtest(ohlc, trading_strategy, cash=cash, commission=commission)
        
        try:
            # Optimize the strategy's parameters (like allocation or stop-loss) for this specific fold.
            # This is a form of walk-forward optimization, which is very robust.
            stats = bt.optimize(
                allocation_percentage=list(np.arange(0.01, 1.01, 0.05)),
                sl_percentage=list(np.arange(0.01, 0.11, 0.01)),
                maximize='Return [%]', # Or any other metric to maximize
                # finalize_trades=True # The typo was here; corrected to `finalize_trades=True`
            )
        except Exception as e:
            # Handle cases where the optimization fails
            print(f"Optimization failed for fold {fold+1} with error: {e}")
            stats = None

        if stats is not None and stats._equity_curve is not None:
            # Store the results from this successful fold.
            all_stats.append(stats)
            equity_curves.append(stats._equity_curve)
        else:
            print(f"Skipping fold {fold+1}: No valid stats or equity curve found.")

    # --- Aggregate and Summarize Results ---
    # Concatenate the equity curves from each successful fold to form a single,
    # continuous equity line for the entire backtest period.
    if not equity_curves:
        # If no folds were successful, raise an error.
        raise ValueError("No successful backtest folds. Cannot concatenate equity curves.")
        
    # Concatenate and sort to ensure the final curve is chronological.
    full_equity = pd.concat(equity_curves).sort_index()

    # Aggregate fold metrics by calculating the mean and standard deviation.
    # This provides a comprehensive summary of the strategy's performance.
    metrics_summary = pd.DataFrame([s[["Return [%]", "Sharpe Ratio", "Max. Drawdown [%]"]] for s in all_stats])
    metrics_summary.loc["Mean"] = metrics_summary.mean()
    metrics_summary.loc["Std"] = metrics_summary.std()

    return all_stats, full_equity, metrics_summary
